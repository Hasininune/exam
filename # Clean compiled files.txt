# Clean compiled files
mvn clean

# Compile code
mvn compile

# Run tests
mvn test

# Package into JAR/WAR
mvn package

# Install into local repository
mvn install

# Clean and build skipping tests
mvn clean package -DskipTests

GIT COMMANDS

# Clone repository
git clone <repo_url>

# Check project status
git status

# Stage and commit changes
git add .
git commit -m "message"

# Push changes to remote
git push origin main

# Pull latest changes
git pull origin main

# Create and switch to a new branch
git checkout -b feature/branchname

# See all branches
git branch -a

# View commit history (pretty graph)
git log --oneline --graph --decorate --all

# Unstage a file
git reset HEAD filename

# Discard local changes
git checkout -- filename

# Merge branch into current
git merge origin/main

# Delete remote branch
git push origin --delete branchname

# Apply patch from teammate
git apply teammate_patch.patch


DOCKER INSIDE MAVEN
# Use Maven to build
FROM maven:3.8.6-jdk-11 AS build
WORKDIR /app
COPY . .
RUN mvn clean package -DskipTests

# Use Tomcat to run
FROM tomcat:9.0
COPY --from=build /app/target/HospitalMgmtSystem.war /usr/local/tomcat/webapps/HospitalMgmtSystem.war
EXPOSE 8080
CMD ["catalina.sh", "run"]
FROM tomcat:9.0
COPY target/*.war /usr/local/tomcat/webapps/
EXPOSE 7007
CMD ["catalina.sh","run"]
# First, build WAR locally
mvn clean package -DskipTests

# Build Docker image
docker build -t hospital-mgmt .

# Run container (map host port 7007 to container port 8080)
docker run -d -p 7007:8080 hospital-mgmt

# Verify container
docker ps

# Access app in browser
http://localhost:7007/HospitalMgmtSystem

# Stop container
docker stop <container_id>


DOCKER COMMANDS
# Build image
docker build -t hospital-mgmt .

# List images
docker images

# Run container (map port 8080)
docker run -d -p 8080:8080 hospital-mgmt

# Check running containers
docker ps

# Stop container
docker stop <container_id>

# Remove container
docker rm <container_id>

# Push image to Docker Hub
docker login
docker tag hospital-mgmt yourusername/hospital-mgmt
docker push yourusername/hospital-mgmt

YML FILE:
version: "3.8"
services:
  app:
    image: yourusername/hospital-mgmt
    container_name: hospital_app
    ports:
      - "7079:8080"
    depends_on:
      - db

  db:
    image: mongo:5.0
    container_name: hospital_db
    ports:
      - "27017:27017"
# Start services
docker-compose up -d

# Check running containers
docker ps

# Stop services
docker-compose down


GIT COMMANDS:
# Set your identity
git config --global user.name "Your Name"
git config --global user.email "you@example.com"

# Check configuration
git config --list


# Initialize new repo
git init

# Clone an existing repo
git clone <repo_url>

# Add remote (link local repo to GitHub)
git remote add origin <repo_url>

# Verify remote
git remote -v

# Change remote URL
git remote set-url origin <new_repo_url>

# Stage a single file
git add filename

# Stage multiple files
git add file1 file2

# Stage all changes
git add .

# Unstage a file (keep changes)
git reset HEAD filename

# Discard file changes
git checkout -- filename

# Commit with message
git commit -m "Your commit message"

# Commit with detailed message
git commit

# List branches
git branch

# Create new branch
git branch feature-branch

# Switch branch
git checkout feature-branch

# Create and switch
git checkout -b feature-branch

# Delete branch
git branch -d branchname

# Force delete
git branch -D branchname

# List remotes
git remote -v

# Add new remote
git remote add origin <repo_url>

# Remove remote
git remote remove origin

# Show info about remote
git remote show origin


# Push branch to remote
git push origin branchname

# Push to default remote branch
git push

# Push all branches
git push --all

# Pull latest changes
git pull origin branchname

# Pull with rebase
git pull --rebase origin branchname

# Fetch latest from remote (without merging)
git fetch origin

# Fetch all branches
git fetch --all

# Prune deleted branches
git fetch --prune

# Merge a branch into current branch
git merge branchname

# Abort a conflicted merge
git merge --abort

# Rebase current branch onto another
git rebase branchname

# Continue rebase after fixing conflicts
git rebase --continue

# Simple log
git log

# One-line log
git log --oneline

# Log with graph
git log --oneline --graph --decorate --all

# Show commits of a file
git log filename

# Show changes in last commit
git show

# Show commit history with patches
git log -p

# Check current status
git status

# See staged changes
git diff --cached

# See unstaged changes
git diff

# Check who changed a file (blame)
git blame filename

# Undo last commit (keep changes staged)
git reset --soft HEAD~1

# Undo last commit (keep changes unstaged)
git reset --mixed HEAD~1

# Undo last commit (discard changes)
git reset --hard HEAD~1

# Revert a specific commit
git revert <commit_id>

# Create tag
git tag v1.0.0

# Annotated tag
git tag -a v1.0.0 -m "Version 1.0.0 release"

# List tags
git tag

# Push tags
git push origin --tags

# Delete tag
git tag -d v1.0.0

WEEK-6 DOCKER COMPOSE:
Example:
	
services:
  web:
    image: nginx
    ports:
      - "8060:80"
  db:
    image: tomee
    ports:
      - "8050:8080"

3.	Networks: Define networks to allow different services to communicate with each other. Docker Compose automatically creates a default network if not specified.

4.	Volumes: Used for persistent storage, allowing data to persist even after the container stops or is removed.

Example Docker Compose File (Simple)
Here’s a basic example of a Docker Compose file that runs WordPress and MySQL together:
version: '3.8'  # Docker Compose file format version

services:
  wordpress:  # WordPress service
    image: wordpress:latest
    ports:
      - "8080:80"  # Map port 80 of the container to port 8080 of the host
    environment:
      WORDPRESS_DB_HOST: db:3306  # Database host
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    depends_on:
      - db  # Ensures the db service starts first

  db:  # MySQL service
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress

How to Run It
To run a multi-container setup like the one above:
1.	Save the file as docker-compose.yml.
                Or
docker-compose.yaml
2.	To Start the compose

docker-compose up –d

3.	To stop the containers 
       docker-compose down
4.	To scale the container

docker-compose up --scale <service name>=2 -d

1.Define and run multiple interdependent services

Task:
I.	Create a new folder compose-lab
Inside it, create a file docker-compose.yml with the following content:

version: "3.9"
services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: demo
      POSTGRES_PASSWORD: demo
      POSTGRES_DB: demo_db

II. Run the setup:

docker compose up -d

III. Open your browser and visit: http://localhost:8080.

IV. Expected Output:

Nginx welcome page is displayed.
db container runs in the background.

2.Write and interpret docker-compose.yml files
Task:
I.	Modify docker-compose.yml to add a Redis cache:

  redis:
    image: redis:alpine

II. Add a depends_on so web waits for Redis:
  web:
    image: nginx:latest
    ports:
      - "8080:80"
    depends_on:
      - redis

III. Restart the setup:
docker compose up -d
docker compose ps

IV. Expected Output:

Three services (web, db, redis) are listed as running.

3.Deploy across different machines
Task:
I.	Zip your compose-lab folder.

Transfer it to another machine with Docker Compose installed.

II. Run:
docker compose up -d

Check that Nginx and Postgres work there as well.

III. Expected Output:
The same services run on the new machine without changes.

4.Networking and persistent storage
Task:
I.	Update your docker-compose.yml to add a custom network and volume:

networks:
  app-net:

volumes:
  db-data:

services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"
    networks:
      - app-net
    depends_on:
      - db

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: demo
      POSTGRES_PASSWORD: demo
      POSTGRES_DB: demo_db
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - app-net

II. Run:
docker compose up -d
III. Insert some data into Postgres (optional with psql).
IV. Remove containers:
docker compose down
V. Start again:
docker compose up -d
VI. Expected Output:
Database data persists across restarts.
Services communicate via the app-net network using service names.

5.Faster iteration during development
Task: 
I.	Create a simple Flask app in app.py:

from flask import Flask
app = Flask(__name__)
@app.route("/")
def home():
    return "Hello from Flask + Docker!"
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

II. Add a Dockerfile in the same folder:

FROM python:3.10-slim
WORKDIR /app
COPY app.py /app/
RUN pip install flask
CMD ["python", "app.py"]

III. Update docker-compose.yml:
  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db
IV. Run:
docker compose up --build
Visit http://localhost:5000.
Change the return text in app.py (e.g., "Hello Docker Compose!").
V. Rebuild:
docker compose up --build
VI. Expected Output:
New message appears instantly after rebuild.


WEEK-5:
Step 1: Pull the redis Image
Command:
docker pull redis
Step 2: Run a Redis Container
Command:
docker run --name my-redis -d redis
What It Does:
• Creates and starts a container named my-redis from the redis image.
• The -d flag runs the container in the background.
Step 3: Check Running Containers
Command:
docker ps
What It Does:
• Lists all running containers.
Step 4: Access Redis
Command:
docker exec -it my-redis redis-cli
Opens the Redis command-line tool (redis-cli) inside the container.
Example Redis Commands:
127.0.0.1:6379> SET name "Alice"
OK
127.0.0.1:6379> GET name
"Alice"
Step 5: Stop the Redis Container
Command:
docker stop my-redis
What It Does:
• Stops the Redis container but doesn’t delete it.
Step 6: Restart the Redis Container
Command:
docker start my-redis
What It Does:
• Restarts the stopped container.
Step 7: Remove the Redis Container
Command:
docker rm my-redis
What It Does:
• Deletes the container permanently.
Step 8: Remove the Redis Image
Command:
docker rmi redis
What It Does:
• Deletes the Redis image from your local system.
2.Working with Docker file
A Docker file is a text file with instructions to create a custom Docker image.
Step 1: Set Up Your Folder
1. Windows:
o Create a folder like C:\DockerProjects\Redis.
o Open Git Bash and navigate to the folder:
cd /c/DockerProjects/Redis
2. Mac/Linux:
o Create a folder:
mkdir ~/DockerProjects/Redis
cd ~/DockerProjects/Redis
Step 2: Write the Dockerfile
1. Inside the folder, create a file named Dockerfile (no extension).
2. Add the following content:
FROM redis:latest
CMD ["redis-server"]
Docker Commands (Step-by-step):
1. docker build -t redisnew  .
What it does:
• This creates (builds) a Docker image using the recipe (Dockerfile) in the current
folder (.).
• -t redisnew: Gives the image a name/tag ("redisnew"), so you can find it easily.
2. docker run --name myredisnew -d redisnew
What it does:
• Starts a new container (mini computer) from the redisnew image.
• --name myredisnew: Names the container "myredisnew" so it’s easy to identify.
• -d: Runs the container in the background.
3. docker ps
What it does:
• Shows a list of containers that are running right now.
4. docker stop myredisnew
What it does:
• Stops the container named "myredisnew" (like turning off a computer).
5. docker login
What it does:
• Logs you into your Docker Hub account, so you can upload images.
6. docker ps -a
What it does:
• Shows a list of all containers, including stopped ones.
7. docker commit 0e993d2009a1 budarajumadhurika/redis1
What it does:
• Takes a snapshot (saves changes) of the container with ID 0e993d2009a1 and creates a
new image called budarajumadhurika/redis1.
8. docker images
What it does:
• Lists all images saved on your system.
9. docker push budarajumadhurika/redis1
What it does:
• Uploads the image budarajumadhurika/redis1 to Docker Hub, so others can download
it.
10. docker rm 0e993d2009a1
What it does:
• Deletes the container with ID 0e993d2009a1.
11. docker rmi budarajumadhurika/redis1
What it does:
• Deletes the image budarajumadhurika/redis1 from your system.
12. docker ps -a
What it does:
Shows all containers again to confirm changes.
13. docker logout
What it does:
• Logs you out of Docker Hub.
14. docker pull budarajumadhurika/redis1
What it does:
• Downloads the image budarajumadhurika/redis1 from Docker Hub.
15. docker run --name myredis -d budarajumadhurika/redis1
What it does:
• Starts a new container using the image budarajumadhurika/redis1.
16. docker exec -it myredis redis-cli
What it does:
• Opens the Redis command-line interface (like a terminal) inside the running container
myredis.
17. SET name "Abcdef"
What it does:
• Saves a key-value pair in Redis (key = name, value = Abcdef).
18. GET name
What it does:
• Retrieves the value of the key name from Redis (it will return "Abcdef").
19. exit
What it does:
• Exits the Redis CLI.
20. docker ps -a
What it does:
• Shows all containers again to check their status.
21. docker stop myredis
What it does:
• Stops the container myredis.
22. docker rm 50a6e4a9c326
What it does:
• Deletes the container with ID 50a6e4a9c326.
23. docker images
What it does:
• Lists all images again to confirm which ones remain.
24. docker rmi budarajumadhurika/redis1
What it does:
• Deletes the image budarajumadhurika/redis1 again.
Step 3: Remove Login Credentials (Optional)
If you no longer need to be logged in, you can log out:
docker logout
What It Does:
• Logs you out from Docker Hub and removes your stored credentials.
